"""
Alert Models for Fluxo
Defines alert types, triggers, and delivery formats
"""
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from datetime import datetime
from enum import Enum


class AlertSeverity(str, Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    HIGH = "high"
    CRITICAL = "critical"


class AlertType(str, Enum):
    """Types of alerts the system can generate"""
    # Risk-based alerts
    HIGH_RISK_SCORE = "high_risk_score"
    CRITICAL_RISK_SCORE = "critical_risk_score"
    CONCENTRATION_WARNING = "concentration_warning"
    LIQUIDITY_RISK = "liquidity_risk"
    CONTRACT_RISK = "contract_risk"
    MARKET_STRESS = "market_stress"
    
    # Whale alerts
    WHALE_MOVEMENT = "whale_movement"
    LARGE_TRANSFER = "large_transfer"
    
    # Social alerts
    SENTIMENT_SHIFT = "sentiment_shift"
    NARRATIVE_TRENDING = "narrative_trending"
    
    # Opportunity alerts
    YIELD_OPPORTUNITY = "yield_opportunity"
    REBALANCE_SUGGESTION = "rebalance_suggestion"


class AlertTrigger(BaseModel):
    """
    Defines when an alert should be triggered
    """
    alert_type: AlertType
    threshold: float
    comparison: str  # "gt", "lt", "gte", "lte", "eq"
    cooldown_minutes: int = 60  # Don't trigger same alert within this time
    
    def should_trigger(self, current_value: float, last_triggered: Optional[datetime] = None) -> bool:
        """Check if alert should be triggered"""
        # Check cooldown
        if last_triggered:
            time_since = (datetime.utcnow() - last_triggered).total_seconds() / 60
            if time_since < self.cooldown_minutes:
                return False
        
        # Check threshold
        if self.comparison == "gt":
            return current_value > self.threshold
        elif self.comparison == "gte":
            return current_value >= self.threshold
        elif self.comparison == "lt":
            return current_value < self.threshold
        elif self.comparison == "lte":
            return current_value <= self.threshold
        elif self.comparison == "eq":
            return current_value == self.threshold
        
        return False


class Alert(BaseModel):
    """
    An alert generated by the system
    """
    alert_id: str
    alert_type: AlertType
    severity: AlertSeverity
    title: str
    message: str
    wallet_address: Optional[str] = None
    
    # Context data
    current_value: Optional[float] = None
    threshold: Optional[float] = None
    details: Dict[str, Any] = Field(default_factory=dict)
    
    # Metadata
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    triggered_by: str  # Which agent triggered this
    
    # Delivery tracking
    delivered: bool = False
    delivery_method: Optional[str] = None  # "x402", "telegram", "webhook"
    
    def to_dict(self):
        return {
            "alert_id": self.alert_id,
            "type": self.alert_type.value,
            "severity": self.severity.value,
            "title": self.title,
            "message": self.message,
            "wallet_address": self.wallet_address,
            "current_value": self.current_value,
            "threshold": self.threshold,
            "details": self.details,
            "timestamp": self.timestamp.isoformat(),
            "triggered_by": self.triggered_by,
            "delivered": self.delivered
        }


class AlertRule(BaseModel):
    """
    User-configurable alert rules
    """
    rule_id: str
    user_wallet: str
    alert_type: AlertType
    enabled: bool = True
    
    # Threshold configuration
    threshold: float
    comparison: str = "gte"
    
    # Delivery preferences
    delivery_methods: List[str] = ["x402"]  # x402, telegram, email
    
    # Frequency control
    cooldown_minutes: int = 60
    max_alerts_per_day: int = 10
    
    created_at: datetime = Field(default_factory=datetime.utcnow)
    last_triggered: Optional[datetime] = None


class AgentAlertSummary(BaseModel):
    """Summary of alerts from a single agent"""
    agent_name: str  # "risk", "macro", "social"
    alerts_count: int
    severity: AlertSeverity
    primary_title: str
    details: Dict[str, Any] = Field(default_factory=dict)


class AgentSection(BaseModel):
    """Structured section for front-end display for each agent"""
    agent_name: str
    section_title: str
    message: str
    severity: AlertSeverity
    key_metrics: Dict[str, Any] = Field(default_factory=dict)
    items: List[Dict[str, Any]] = Field(default_factory=list)


class ConsolidatedAlert(BaseModel):
    """
    Consolidated multi-agent alert for a wallet.

    Designed for front-end display: contains structured sections per agent,
    a short header message, and raw alerts for reference.
    """
    alert_id: str = Field(default_factory=lambda: str(__import__('uuid').uuid4()))

    # Primary info
    wallet_address: str
    title: str = "Portfolio Analysis Summary"

    # Severity and priority
    overall_severity: AlertSeverity

    # Structured sections for front-end
    agent_sections: List[AgentSection] = Field(default_factory=list)

    # Consolidated metrics
    total_alerts_triggered: int = 0
    risk_score: Optional[float] = None
    risk_level: Optional[str] = None
    market_condition: Optional[str] = None

    # Short header message suitable for notification list
    message: str = ""

    # All risk factors (from risk agent)
    risk_factors: Dict[str, float] = Field(default_factory=dict)

    # Recommendations across all agents
    recommendations: List[str] = Field(default_factory=list)

    # Metadata
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    analyses_completed: List[str] = Field(default_factory=list)  # ["risk", "macro", "social"]

    # Storage and delivery
    delivered: bool = False
    delivery_method: Optional[str] = None

    # Raw alert details for reference
    raw_alerts: List[Dict[str, Any]] = Field(default_factory=list)

    def to_dict(self):
        """Convert to dictionary for JSON serialization"""
        return {
            "alert_id": self.alert_id,
            "wallet_address": self.wallet_address,
            "title": self.title,
            "overall_severity": self.overall_severity.value,
            "total_alerts_triggered": self.total_alerts_triggered,
            "risk_score": self.risk_score,
            "risk_level": self.risk_level,
            "market_condition": self.market_condition,
            "message": self.message,
            "agent_sections": [s.model_dump() for s in self.agent_sections],
            "risk_factors": self.risk_factors,
            "recommendations": self.recommendations,
            "timestamp": self.timestamp.isoformat(),
            "analyses_completed": self.analyses_completed,
            "delivered": self.delivered,
            "raw_alerts": self.raw_alerts,
        }

    def to_json(self):
        """Convert to JSON string"""
        import json
        return json.dumps(self.to_dict())

