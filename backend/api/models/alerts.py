"""
Alert Models for Fluxo
Defines alert types, triggers, and delivery formats
"""
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
from datetime import datetime
from enum import Enum


class AlertSeverity(str, Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    HIGH = "high"
    CRITICAL = "critical"


class AlertType(str, Enum):
    """Types of alerts the system can generate"""
    # Risk-based alerts
    HIGH_RISK_SCORE = "high_risk_score"
    CRITICAL_RISK_SCORE = "critical_risk_score"
    CONCENTRATION_WARNING = "concentration_warning"
    LIQUIDITY_RISK = "liquidity_risk"
    CONTRACT_RISK = "contract_risk"
    MARKET_STRESS = "market_stress"
    
    # Whale alerts
    WHALE_MOVEMENT = "whale_movement"
    LARGE_TRANSFER = "large_transfer"
    
    # Social alerts
    SENTIMENT_SHIFT = "sentiment_shift"
    NARRATIVE_TRENDING = "narrative_trending"
    
    # Opportunity alerts
    YIELD_OPPORTUNITY = "yield_opportunity"
    REBALANCE_SUGGESTION = "rebalance_suggestion"


class AlertTrigger(BaseModel):
    """
    Defines when an alert should be triggered
    """
    alert_type: AlertType
    threshold: float
    comparison: str  # "gt", "lt", "gte", "lte", "eq"
    cooldown_minutes: int = 60  # Don't trigger same alert within this time
    
    def should_trigger(self, current_value: float, last_triggered: Optional[datetime] = None) -> bool:
        """Check if alert should be triggered"""
        # Check cooldown
        if last_triggered:
            time_since = (datetime.utcnow() - last_triggered).total_seconds() / 60
            if time_since < self.cooldown_minutes:
                return False
        
        # Check threshold
        if self.comparison == "gt":
            return current_value > self.threshold
        elif self.comparison == "gte":
            return current_value >= self.threshold
        elif self.comparison == "lt":
            return current_value < self.threshold
        elif self.comparison == "lte":
            return current_value <= self.threshold
        elif self.comparison == "eq":
            return current_value == self.threshold
        
        return False


class Alert(BaseModel):
    """
    An alert generated by the system
    """
    alert_id: str
    alert_type: AlertType
    severity: AlertSeverity
    title: str
    message: str
    wallet_address: Optional[str] = None
    
    # Context data
    current_value: Optional[float] = None
    threshold: Optional[float] = None
    details: Dict[str, Any] = Field(default_factory=dict)
    
    # Metadata
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    triggered_by: str  # Which agent triggered this
    
    # Delivery tracking
    delivered: bool = False
    delivery_method: Optional[str] = None  # "x402", "telegram", "webhook"
    
    def to_dict(self):
        return {
            "alert_id": self.alert_id,
            "type": self.alert_type.value,
            "severity": self.severity.value,
            "title": self.title,
            "message": self.message,
            "wallet_address": self.wallet_address,
            "current_value": self.current_value,
            "threshold": self.threshold,
            "details": self.details,
            "timestamp": self.timestamp.isoformat(),
            "triggered_by": self.triggered_by,
            "delivered": self.delivered
        }


class AlertRule(BaseModel):
    """
    User-configurable alert rules
    """
    rule_id: str
    user_wallet: str
    alert_type: AlertType
    enabled: bool = True
    
    # Threshold configuration
    threshold: float
    comparison: str = "gte"
    
    # Delivery preferences
    delivery_methods: List[str] = ["x402"]  # x402, telegram, email
    
    # Frequency control
    cooldown_minutes: int = 60
    max_alerts_per_day: int = 10
    
    created_at: datetime = Field(default_factory=datetime.utcnow)
    last_triggered: Optional[datetime] = None
